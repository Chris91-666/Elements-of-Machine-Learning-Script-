

\chapter{Cryptanalysis}

\textbf{Finding Collisions in a list or between lists}
\begin{itemize}
    \item This is a major algorithmic tool in cryptanalysis
    \item Can be done in quasi-linear time in the lists’ sizes
    \item Basic idea for a single list:
    \begin{itemize}
        \item Sort the list of size $N$ (takes $O(N \cdot log(N))$ comparisons)
        \item Read it in order. Collisions will be between consecutive elements!
        \item Any ordering of the elements work (a natural ordering isn’t needed)
    \end{itemize}
    \item With two lists:
    \begin{itemize}
        \item Sort both
        \item Start at the beginning of both lists, compare elements, advance the smallest
        \item Iterate until a collision is found
    \end{itemize}
\end{itemize}
\begin{center}
    Extra care needed to get \textbf{all} collisions\newline
\end{center}


\textbf{Differential Cryptoanalysis (principle of the attack)}
\begin{itemize}
    \item Assume we have $\Delta I \to_p \Delta O$ for a block cipher (with $p >> 2^{-n}$)
    \begin{itemize}
        \item Encrypt many pairs with input difference
        \item For the studied cipher $\Delta O$ is observed with probability close to $p$
        \item For a random permutation $\Delta O$ is observed with probability close to $2^{-n}$
    \end{itemize}
    \item This yields a chosen plaintext distinguisher from a random permutation!
    \item For key recovery, use the distinguisher on a restricted num of rounds
    \item Together with exhaustive key search on (part of) the removed rounds\newline
\end{itemize}


\textbf{Linear Cryptoanalysis (principle of attack)}
\begin{itemize}
    \item Assume we have $m_1 \mapsto_{\epsilon} m_0$ for a block cipher (with $\epsilon >> 2^{-n}$)
    \begin{itemize}
        \item Encrypt with inputs $I$ with output $O$, compute $(m_I \odot I) \oplus (m_O \odot O)$
        \item For the studied cipher, large difference between num of zeroes and ones
        \item For a random permutation, close to balance between zeroes and ones
    \end{itemize}
    \item This yields a known plaintext distinguisher from a random permutation!
    \item For key recovery, we can take advantage of key mixed in using XORs\newline
\end{itemize}

